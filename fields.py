import numpy as np import matplotlib.pyplot as plt import matplotlib.cm as cm  class Field_Fun:     """For 'shape', the user enters one of a variety of shapes of objects of some shape (i.e. infinite wire, wire,     sphere, etc. For x and y distance, the user enters either a specific distance or range of distances they want to measure the    field from. For Q, the user enters the initial surface charge or charge density that is pertinent to the   shape he or she is       looking at. For origin, the user enters the x-y coordinates as a list of where the field is goingto be measured from"""      #shape must be input as a string, origin must be input as a list with the first component as the x position and the second        #as the y position.     def __init__(self, shape, xdistance, ydistance, Q, origin):         self.shape = shape         self.xdistance = xdistance         self.ydistance = ydistance         self.Q = Q         self.origin = origin         self.K = 8.9875517873681764 * (10**9)         self.epsilon = 8.85418782/(10**12)      #This function assumes all shapes are situated parallel to the x-axis     def field(self, R=0):         xfield = 0         yfield = 0         if self.shape == 'point' or self.shape == 'shpere':             xfield = (self.Q * self.K)/(np.linspace(self.origin[0] + .0000000001, self.xdistance, 30)**2)             yfield = (self.Q * self.K)/(np.linspace(self.origin[1] + .0000000001, self.ydistance, 30)**2)         elif self.shape == 'infinite plane':             yfield = self.Q/(2 * self.epsilon)         elif self.shape == 'infinite wire':             yfield = self.Q/(2 * np.pi * self.ydistance * self.epsilon)         #The origin of the parallel plate capacitor will be the center of the bottom plate, and the top plate will simply be         #there so the graph looks easy on the eyes.         elif self.shape == 'parallel plate capacitor':             yfield = self.Q/self.epsilon         return xfield, yfield      #This function is used to find the potential difference for some range r1 to r2     '''def potential(self):         X, Y = self.field()         xpotential = X * -1 * (self.xdistance - self.origin[0])         ypotential = Y * -1 * (self.ydistance - self.origin[1])         return xpotential, ypotential'''       #This function will graph one of the types of fields that you want to make, where Efield is the electric field     #Vfield is the potential graph.     def graph_the_bitch(self, typ):         Xone = np.linspace(self.origin[0] - self.xdistance, self.origin[0] + self.xdistance, 30)         Yone = np.linspace(self.origin[1] - self.ydistance, self.origin[1] + self.ydistance, 30)         X, Y = np.meshgrid(Xone, Yone)         rotator = np.arctan2(Y - self.ydistance, X - self.xdistance)         #rotator1 = np.arctan((Y-self.ydistance)/(X-self.xdistance))             R, M = self.field()         U = np.cos(rotator) * R + np.sin(rotator) * M         V = -np.sin(rotator) * R + np.cos(rotator) * M         XX = np.sqrt((U**2) + (V**2))         plt.imshow(XX, cmap=cm.coolwarm)         #Below just add aditional lines to the graph to give you a sense of where the objects with electric field are with         #respect to the field vectors         if self.shape == 'point' or self.shape == 'sphere':             plt.quiver(X, Y, U, V, angles='xy', scale_units='xy', scale = 8)             plt.scatter(self.origin[0], self.origin[1], marker='o')         elif self.shape == 'infinite plane' or self.shape == 'infinite wire':             plt.quiver(X, Y, U, V, angles='xy', scale_units='xy', scale = 10)             x = np.linspace(-self.xdistance, self.xdistance, self.xdistance * 50)             y = np.full(self.xdistance * 50, self.origin[1])             plt.plot(x, y, c='red')         elif self.shape == 'parallel plate capacitor':             plt.quiver(X, Y, U, V, angles='xy', scale_units='xy', scale = 1)             x = np.linspace(-self.xdistance, self.xdistance, self.xdistance * 50)             y = np.full(self.xdistance * 50, self.ydistance)             plt.plot(x,y, c='red')             plt.plot(x,y + self.ydistance, c='blue')         plt.xlim((self.origin[0] - self.xdistance, self.xdistance + self.origin[0]))         plt.ylim((self.origin[1] - self.ydistance, self.ydistance + self.origin[1]))         plt.show() 
